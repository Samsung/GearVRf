/* Copyright 2015 Samsung Electronics Co., LTD
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.gearvrf;

import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.concurrent.CopyOnWriteArrayList;

import org.gearvrf.GVRMaterial.GVRShaderType;
import org.gearvrf.GVRMaterial.GVRShaderType.Texture;
import org.gearvrf.script.IScriptable;
import org.gearvrf.utility.Log;
import org.joml.Vector3f;

/**
 * Describes a 3D object in the scene with a position and orientation.
 *
 * Every scene object has a {@linkplain #getTransform() location}, and can have
 * {@linkplain #children() children}. An invisible scene object can be used to
 * move a set of scene as a unit, preserving their relative geometry. Invisible
 * scene objects don't need any {@linkplain GVRSceneObject#getRenderData()
 * render data.}
 *
 * <p>
 * Visible scene objects must have render data
 * {@linkplain GVRSceneObject#attachRenderData(GVRRenderData) attached.} Each
 * {@link GVRRenderData} has a {@link GVRMesh GL mesh} that defines its
 * geometry, and a {@link GVRMaterial} that defines its surface.
 * <p>
 * Components can be attached to a scene object to extend its functionality.
 * For example, you can attach a light component to make the scene object illuminate
 * other objects. Only one component of a particular type can be attached.
 * Components are retrieved based on their type.
 * <p>
 * {@link GVRSceneObject} receives events defined in {@link ISceneObjectEvents}. To add a listener
 * to these events, use the following code:
 * <pre>
 *     ISceneObjectEvents myEventListener = new ISceneObjectEvents() {
 *         ...
 *     };
 *     getEventReceiver().addListener(myEventListener);
 * </pre>
 */
public class GVRSceneObject extends GVRHybridObject implements PrettyPrint, IScriptable, IEventReceiver {
    private Map<Long, GVRComponent> mComponents = new HashMap<Long, GVRComponent>();
    private GVRSceneObject mParent;
    private Object mTag;
    private final List<GVRSceneObject> mChildren = new CopyOnWriteArrayList<GVRSceneObject>();
    private final GVREventReceiver mEventReceiver = new GVREventReceiver(this);

    /**
     * Constructs an empty scene object with a default {@link GVRTransform
     * transform}.
     *
     * @param gvrContext
     *            current {@link GVRContext}
     */
    public GVRSceneObject(GVRContext gvrContext) {
        this(gvrContext, null);
    }

    /**
     * Constructs a scene object with an arbitrarily complex mesh.
     *
     * @param gvrContext
     *            current {@link GVRContext}
     * @param mesh
     *            a {@link GVRMesh} - usually generated by one of the
     *            {@link GVRAssetLoader#loadMesh(GVRAndroidResource)} methods, or
     *            {@link GVRContext#createQuad(float, float)}
     */
    public GVRSceneObject(GVRContext gvrContext, GVRMesh mesh) {
        this(gvrContext, mesh, null, null);
    }

    /**
     * Constructs a rectangular scene object, whose geometry is completely
     * specified by the width and height.
     *
     * @param gvrContext
     *            current {@link GVRContext}
     * @param width
     *            the scene object's width
     * @param height
     *            the scene object's height
     */
    public GVRSceneObject(GVRContext gvrContext, float width, float height) {
        this(gvrContext, gvrContext.createQuad(width, height));
    }

    /**
     * The base texture constructor: Constructs a scene object with
     * {@linkplain GVRMesh an arbitrarily complex geometry} that uses a specific
     * shader to display a {@linkplain GVRTexture texture.}
     *
     * @param gvrContext
     *            current {@link GVRContext}
     * @param mesh
     *            a {@link GVRMesh} - usually generated by one of the
     *            {@link GVRContext#getAssetLoader()#loadMesh(GVRAndroidResource)} methods, or
     *            {@link GVRContext#createQuad(float, float)}
     * @param texture
     *            a {@link GVRTexture}
     * @param shaderId
     *            a specific shader Id - see {@link GVRShaderType} and
     *            {@link GVRShaderManager}
     *
     */
    public GVRSceneObject(GVRContext gvrContext, GVRMesh mesh,
                          GVRTexture texture, GVRShaderId shaderId) {
        super(gvrContext, NativeSceneObject.ctor());
        attachComponent(new GVRTransform(getGVRContext()));

        if ((mesh == null) && (texture == null)) {
            return;
        }
        GVRRenderData renderData = new GVRRenderData(gvrContext);
        attachComponent(renderData);
        if (mesh != null) {
            renderData.setMesh(mesh);
        }
        if (shaderId == null) {
            shaderId = GVRShaderType.Texture.ID;
        }
        GVRMaterial material = new GVRMaterial(gvrContext, shaderId);
        if (texture != null) {
            material.setMainTexture(texture);
        }
        renderData.setMaterial(material);
    }

    public GVRSceneObject(GVRContext gvrContext, GVRMesh mesh, GVRMaterial material) {
        super(gvrContext, NativeSceneObject.ctor());
        attachComponent(new GVRTransform(getGVRContext()));

        GVRRenderData renderData = new GVRRenderData(gvrContext, material);
        attachComponent(renderData);
        renderData.setMesh(mesh);
    }

    private static final GVRShaderId STANDARD_SHADER = GVRShaderType.Texture.ID;

    /**
     * Constructs a scene object with {@linkplain GVRMesh an arbitrarily complex
     * geometry} that uses the standard {@linkplain Texture 'texture shader'} to
     * display a {@linkplain GVRTexture texture.}
     *
     *
     * @param gvrContext
     *            current {@link GVRContext}
     * @param mesh
     *            a {@link GVRMesh} - usually generated by one of the
     *            {@link GVRAssetLoader#loadMesh(GVRAndroidResource)} methods, or
     *            {@link GVRContext#createQuad(float, float)}
     * @param texture
     *            a {@link GVRTexture}
     */
    public GVRSceneObject(GVRContext gvrContext, GVRMesh mesh,
                          GVRTexture texture) {
        this(gvrContext, mesh, texture, STANDARD_SHADER);
    }

    /**
     * Very high-level constructor that loads the mesh and texture.
     * <p>
     * @param gvrContext
     *            current {@link GVRContext}.
     * @param mesh
     *            A stream containing a mesh file.
     * @param texture
     *            A stream containing a texture file. This can be
     *            either a compressed texture or a regular Android bitmap file.
     *
     * @since 1.6.7
     */
    public GVRSceneObject(GVRContext gvrContext, GVRAndroidResource mesh,
                          GVRAndroidResource texture) {
        this(gvrContext, gvrContext.getAssetLoader().loadMesh(mesh), gvrContext
                .getAssetLoader().loadTexture(texture));
    }

    /**
     * Create a standard, rectangular texture object, using a non-default shader
     * to apply complex visual affects.
     *
     * @param gvrContext
     *            current {@link GVRContext}
     * @param width
     *            the rectangle's width
     * @param height
     *            the rectangle's height
     * @param texture
     *            a {@link GVRTexture}
     * @param shaderId
     *            a specific shader Id
     */
    public GVRSceneObject(GVRContext gvrContext, float width, float height,
                          GVRTexture texture, GVRShaderId shaderId) {
        this(gvrContext, GVRMesh.createQuad(gvrContext, "float3 a_position float2 a_texcoord float3 a_normal", width, height), texture, shaderId);
    }

    /**
     * Create a standard, rectangular texture object, using a non-default shader
     * to apply complex visual affects.
     *
     * @param gvrContext
     *            current {@link GVRContext}
     * @param width
     *            the rectangle's width
     * @param height
     *            the rectangle's height
     * @param meshDesc
     *            string describing vertex format of mesh {@link GVRVertexBuffer()}
     * @param material
     *            {@link GVRMaterial} with material properties
     */
    public GVRSceneObject(GVRContext gvrContext, float width, float height,
                          String meshDesc, GVRMaterial material)
    {
        this(gvrContext, GVRMesh.createQuad(gvrContext, meshDesc, width, height), material);
    }

    /**
     * Constructs a 2D, rectangular scene object that uses the standard
     * {@linkplain Texture 'texture shader'} to display a {@linkplain GVRTexture
     * texture.}
     *
     * @param gvrContext
     *            current {@link GVRContext}
     * @param width
     *            the rectangle's width
     * @param height
     *            the rectangle's height
     * @param texture
     *            a {@link GVRTexture}
     */
    public GVRSceneObject(GVRContext gvrContext, float width, float height,
                          GVRTexture texture) {
        this(gvrContext, width, height, texture, STANDARD_SHADER);
    }

    protected void finalize() throws Throwable
    {
        try {
            detachAllComponents();
        } catch(final Exception exc) {
            exc.printStackTrace();
        } finally {
            super.finalize();
        }
    }

    protected void detachAllComponents()
    {
        synchronized (mComponents)
        {
            for (GVRComponent component : mComponents.values())
            {
                if (component != null)
                {
                    component.setOwnerObject(null);
                }
            }
            mComponents.clear();
        }
    }

    /**
     * Get the (optional) name of the object.
     *
     * @return The name of the object. If no name has been assigned, the
     *         returned string will be empty.
     */
    public String getName() {
        return NativeSceneObject.getName(getNative());
    }

    /**
     * Set the (optional) name of the object.
     *
     * Scene object names are not needed: they are only for the application's
     * convenience.
     *
     * @param name
     *            Name of the object.
     */
    public void setName(String name) {
        NativeSceneObject.setName(getNative(), name);
    }

    /**
     * Sets the tag associated with this scene object.
     *
     * Tags can be used to store data within the scene object without
     * resorting to another data structure.
     *
     * @param tag an object to associate with this scene object
     *
     * @see #getTag()
     */
    public void setTag(Object tag) {
        mTag = tag;
    }

    /**
     * Returns this scene object's tag.
     *
     * @return the Object stored in this scene object as a tag,
     *         or {@code null} if not set
     *
     * @see #setTag(Object)
     */
    public Object getTag() {
        return mTag;
    }

    /**
     * Attach a component to this scene object.
     *
     * Each scene object has a list of components that may
     * be attached to it. Only one component of a particular type
     * can be attached. Components are retrieved based on their type.
     *
     * @return true if component is attached, false if a component of that class is already attached.
     * @param component component to attach.
     * @see GVRSceneObject#detachComponent(long)
     * @see GVRSceneObject#getComponent(long)
     */
    public boolean attachComponent(GVRComponent component) {
        if (component.getNative() != 0) {
            NativeSceneObject.attachComponent(getNative(), component.getNative());
        }
        synchronized (mComponents) {
            long type = component.getType();
            if (!mComponents.containsKey(type)) {
                mComponents.put(type, component);
                component.setOwnerObject(this);
                return true;
            }
        }
        return false;
    }

    /**
     * Detach the component of the specified type from this scene object.
     *
     * Each scene object has a list of components. Only one component
     * of a particular type can be attached. Components are detached based on their type.
     *
     * @return GVRComponent detached or null if component not found
     * @param type  type of component to detach
     * @see GVRSceneObject#attachComponent(GVRComponent)
     */
    public GVRComponent detachComponent(long type) {
        NativeSceneObject.detachComponent(getNative(), type);
        synchronized (mComponents) {
            GVRComponent component = mComponents.remove(type);
            if (component != null) {
                component.setOwnerObject(null);
            }
            return component;
        }
    }

    /**
     * Find the component of the specified class from this scene object.
     *
     * Each scene object has a list of components. Only one component
     * of a particular type can be attached.
     *
     * @return GVRComponent null if component of the given type not found
     * @param type type of component to find
     * @see GVRSceneObject#attachComponent(GVRComponent)
     * @see GVRSceneObject#detachComponent(long)
     */
    public GVRComponent getComponent(long type) {
        return  mComponents.get(type);
    }

    /**
     * Replace the current {@link GVRTransform transform}
     *
     * @param transform
     *            New transform.
     */
    public void attachTransform(GVRTransform transform) {
        attachComponent(transform);
    }

    /**
     * Remove the object's {@link GVRTransform transform}. After this call, the
     * object will have no transformations associated with it.
     */
    public void detachTransform() {
        detachComponent(GVRTransform.getComponentType());
    }

    /**
     * Get the {@link GVRTransform}.
     *
     * A {@link GVRTransform} encapsulates a 4x4 matrix that specifies how to
     * render the {@linkplain GVRMesh GL mesh:} transform methods let you move,
     * rotate, and scale your scene object.
     *
     * @return The current {@link GVRTransform transform}. If no transform is
     *         currently attached to the object, returns {@code null}.
     */
    public GVRTransform getTransform() {
        return (GVRTransform) getComponent(GVRTransform.getComponentType());
    }

    /**
     * Attach {@linkplain GVRRenderData rendering data} to the object.
     *
     * If other rendering data is currently attached, it is replaced with the
     * new data. {@link GVRRenderData} contains the GL mesh, the texture, the
     * shader id, and various shader constants.
     *
     * @param renderData
     *            New rendering data.
     */
    public void attachRenderData(GVRRenderData renderData) {
        attachComponent(renderData);
    }

    /**
     * Detach the object's current {@linkplain GVRRenderData rendering data}.
     *
     * An object with no {@link GVRRenderData} is not visible.
     */
    public void detachRenderData() {
        detachComponent(GVRRenderData.getComponentType());
    }

    /**
     * Get the current {@link GVRRenderData}.
     *
     * @return The current {@link GVRRenderData rendering data}. If no rendering
     *         data is currently attached to the object, returns {@code null}.
     */
    public GVRRenderData getRenderData() {
        return (GVRRenderData) getComponent(GVRRenderData.getComponentType());
    }

    /**
     * Checks if this {@link GVRSceneObject} has mesh. This method is not recursive.
     * That is, if it doesn't have a mesh though its children have, it returns
     * {@code false}.
     *
     * @return true if this {@link GVRSceneObject} contains mesh itself.
     */
    public boolean hasMesh() {
        GVRRenderData rdata = getRenderData();
        return rdata != null && rdata.getMesh() != null;
    }

    /**
     * Attach a new {@link GVRCamera camera} to the object.
     *
     * If another camera is currently attached, it is replaced with the new one.
     *
     * @param camera
     *            New camera.
     */
    public void attachCamera(GVRCamera camera) {
        attachComponent(camera);
    }

    /**
     * Detach the object's current {@link GVRCamera camera}.
     */
    public void detachCamera() {
        detachComponent(GVRCamera.getComponentType());
    }

    /**
     * Get the {@link GVRCamera} attached to the object.
     *
     * @return The {@link GVRCamera camera} attached to the object. If no camera
     *         is currently attached, returns {@code null}.
     */
    public GVRCamera getCamera() {
        return (GVRCamera) getComponent(GVRCamera.getComponentType());
    }

    /**
     * Attach a new {@linkplain GVRCameraRig camera rig.}
     *
     * If another camera rig is currently attached, it is replaced with the new
     * one.
     *
     * @param cameraRig
     *            New camera rig.
     */
    public void attachCameraRig(GVRCameraRig cameraRig) {
        attachComponent(cameraRig);
    }

    /**
     * Detach the object's current {@link GVRCameraRig camera rig}.
     */
    public void detachCameraRig() {
        detachComponent(GVRCameraRig.getComponentType());
    }

    /**
     * Get the attached {@link GVRCameraRig}
     *
     * @return The {@link GVRCameraRig camera rig} attached to the object. If no
     *         camera rig is currently attached, returns {@code null}.
     */
    public GVRCameraRig getCameraRig() {
        return (GVRCameraRig) getComponent(GVRCameraRig.getComponentType());
    }

    /**
     * Get the attached light component. Any subclass of GVRLight may
     * be attached to a scene object. The light's position and direction will be calculated
     * from the transform attached to the scene object.
     * @return The light attached to the object. If no light is currently attached, returns null.
     */
    public GVRLight getLight() {
        return (GVRLight) getComponent(GVRLight.getComponentType());
    }

    /**
     * Attach a new light component.
     *
     * If another light is currently attached, it is replaced with the new
     * one. The light's position and direction will follow the scene object's
     * transform.
     *
     * @param light New light to attach.
     */
    public void attachLight(GVRLight light) {
        attachComponent(light);
    }

    /**
     * Detach the object's current {@link GVRLight}.
     */
    public void detachLight() {
        detachComponent(GVRLight.getComponentType());
    }


    /**
     * Get all components of a specific class from this scene object and its descendants.
     * @param type  component type (as returned from getComponentType())
     * @return ArrayList of components with the specified class.
     */
    @SuppressWarnings("unchecked")
    public <T extends GVRComponent> ArrayList<T> getAllComponents(long type) {
        ArrayList<T> list = new ArrayList<T>();
        GVRComponent component = getComponent(type);
        if (component != null)
            list.add((T) component);
        for (GVRSceneObject child : mChildren) {
            ArrayList<T> temp = child.getAllComponents(type);
            list.addAll(temp);
        }
        return list;
    }

    /**
     * Attach a new {@link GVRCollider} to the object.
     *
     * If another {@link GVRCollider} is currently attached, it is
     * replaced with the new one.
     *
     * @param collider
     *            New {@link GVRCollider}.
     */
    public void attachCollider(GVRCollider collider) {
        attachComponent(collider);
    }

    /**
     * Get the attached {@link GVRCollider}
     *
     * @return The {@link GVRCollider} attached to the object. If no
     *         {@link GVRCollider} is currently attached, returns
     *         {@code null}.
     */
    public GVRCollider getCollider() {
        return (GVRCollider) getComponent(GVRCollider.getComponentType());
    }

    /**
     * Detach the object's current {@link GVRCollider}.
     */
    public void detachCollider() {
        detachComponent(GVRCollider.getComponentType());
    }

    /**
     * Simple, high-level API to enable or disable eye picking for this scene
     * object.
     *
     * The {@linkplain #attachCollider low-level
     * API} gives you a lot of control over eye picking, but it does involve an
     * awful lot of details. This method
     * (and {@link #getPickingEnabled()}) provides a simple boolean property.
     * It attaches a GVRSphereCollider to the scene object. If you want more
     * accurate picking, you can use {@link #attachComponent(GVRComponent)} to attach a
     * mesh collider instead. The mesh collider is more accurate but also
     * costs more to compute.
     *
     * @param enabled
     *            Should eye picking 'see' this scene object?
     *
     * @since 2.0.2
     * @see GVRSphereCollider
     * @see GVRMeshCollider
     */
    public void setPickingEnabled(boolean enabled) {
        if (enabled != getPickingEnabled()) {
            if (enabled) {
                attachComponent(new GVRSphereCollider(getGVRContext()));
            } else {
                detachComponent(GVRCollider.getComponentType());
            }
        }
    }

    /**
     * Is eye picking enabled for this scene object?
     *
     * @return Whether eye picking can 'see' this scene object?
     *
     * @since 2.0.2
     */
    public boolean getPickingEnabled() {
        return getComponent(GVRCollider.getComponentType()) != null;
    }

    /**
     * Get the {@linkplain GVRSceneObject parent object.}
     *
     * If the object has been {@link #addChildObject(GVRSceneObject) added as a
     * child} to another {@link GVRSceneObject}, returns that object. Otherwise,
     * returns {@code null}.
     *
     * @return The parent {@link GVRSceneObject} or {@code null}.
     */
    public GVRSceneObject getParent() {
        return mParent;
    }

    /**
     * Add {@code child} as a child of this object.
     *
     * @param child
     *            {@link GVRSceneObject Object} to add as a child of this
     *            object.
     * @return true if child was added, else false
     */
    public boolean addChildObject(GVRSceneObject child) {
        if (child.mParent == this) {
            return false;
        }
        if (child.mParent != null) {
            throw new UnsupportedOperationException("GVRSceneObject cannot have multiple parents");
        }
        mChildren.add(child);
        child.mParent = this;
        NativeSceneObject.addChildObject(getNative(), child.getNative());
        child.onNewParentObject(this);
        return true;
    }

    /**
     * Remove {@code child} as a child of this object.
     *
     * @param child
     *            {@link GVRSceneObject Object} to remove as a child of this
     *            object.
     */
    public void removeChildObject(GVRSceneObject child) {
        synchronized (mChildren) {
            NativeSceneObject.removeChildObject(getNative(), child.getNative());

            child.mParent = null;
            child.onRemoveParentObject(this);

            mChildren.remove(child);
        }
    }

    protected int removeChildObjectsByNameImpl(final String name) {
        synchronized (mChildren) {
            int count = 0;
            for (GVRSceneObject child : mChildren) {
                if (child.getName().equals(name)) {
                    removeChildObject(child);
                    count++;
                } else {
                    count = count + child.removeChildObjectsByNameImpl(name);
                }
            }
            return count;
        }
    }

    /**
     * Removes any child object that has the given name by performing
     * case-sensitive search.
     *
     * @param name name of scene object to be removed.
     *
     * @return number of removed objects, 0 if none was found.
     */
    public int removeChildObjectsByName(final String name) {
        int removed = 0;

        if (null != name && !name.isEmpty()) {
            removed = removeChildObjectsByNameImpl(name);
        }

        return removed;
    }

    /**
     * Performs case-sensitive depth-first search for a child object and then
     * removes it if found.
     *
     * @param name name of scene object to be removed.
     *
     * @return true if child was found (and removed), else false
     */
    public boolean removeChildObjectByName(final String name) {
        if (null != name && !name.isEmpty()) {
            GVRSceneObject found = null;
            for (GVRSceneObject child : mChildren) {
                GVRSceneObject object = child.getSceneObjectByName(name);
                if (object != null) {
                    found = object;
                    break;
                }
            }
            if (found != null) {
                removeChildObject(found);
                return true;
            }
        }
        return false;
    }

    /**
     * Called when the scene object gets a new parent.
     *
     * @param parent New parent of this scene object.
     */
    protected void onNewParentObject(GVRSceneObject parent) {
        for (GVRComponent comp : mComponents.values()) {
            comp.onNewOwnersParent(parent);
        }
    }

    /**
     * Called when is removed the parent of the scene object.
     *
     * @param parent Old parent of this scene object.
     */
    protected void onRemoveParentObject(GVRSceneObject parent) {
        for (GVRComponent comp : mComponents.values()) {
            comp.onRemoveOwnersParent(parent);
        }
    }

    /**
     * Add the owner of {@code childComponent} as a child of this object. (owner object of the
     * Adding a child will increase the {@link #getChildrenCount()} for this scene object.
     * If the component is not attached to a scene object this function does nothing.
     *
     * @param childComponent
     *            {@link GVRComponent Component} whose owner is added as a child of this
     *            object.
     */
    public void addChildObject(GVRComponent childComponent) {
        if (childComponent.getOwnerObject() != null) {
            addChildObject(childComponent.getOwnerObject());
        }
    }

    /**
     * Remove the owner of {@code childComponent} as a child of this object.
     * Removing a child will decrease the {@link #getChildrenCount()} for this scene object.
     * If the component is not attached to a scene object this function does nothing.
     *
     * @param childComponent
     *            {@link GVRComponent Component} whose owner is removeed as a child of this
     *            object.
     */
    public void removeChildObject(GVRComponent childComponent) {
        if (childComponent.getOwnerObject() != null) {
            removeChildObject(childComponent.getOwnerObject());
        }
    }

    public interface SceneVisitor {
        public boolean visit(GVRSceneObject obj);
    }

    public interface ComponentVisitor {
        public boolean visit(GVRComponent comp);
    }

    /**
     * Visits all the descendants of this scene object.
     * The SceneVisitor.visit function is called for every
     * descendant until it returns false. This allows you
     * to traverse the scene graph safely without copying it.
     * This method gives much better performance than iterating
     * children() or getChildren().
     *
     * @param visitor SceneVisitor interface implementing "visit" function
     * @see #children()
     * @see #getChildren()
     * @see SceneVisitor
     * @see #forAllComponents(ComponentVisitor)
     * @see #forAllComponents(ComponentVisitor, long)
     */
    public void forAllDescendants(SceneVisitor visitor) {
        synchronized (mChildren)
        {
            if (visitor.visit(this))
            {
                for (GVRSceneObject child : mChildren)
                {
                    child.forAllDescendants(visitor);
                }
            }
        }
    }

    /**
     * Visits all the components of the specified type attached to
     * the descendants of this scene object.
     * The ComponentVisitor.visit function is called for every
     * eligible component of each descendant until it returns false.
     * This allows you to traverse the scene graph safely without copying it.
     * This method gives much better performance than iterating
     * children() or getChildren().
     *
     * @param visitor ComponentVisitor interface implementing "visit" function
     * @param componentType type of component to find
     *
     * @see #children()
     * @see #getChildren()
     * @see SceneVisitor
     * @see #forAllDescendants(SceneVisitor)
     * @see #getComponent(long)
     */
    public void forAllComponents(ComponentVisitor visitor, long componentType) {
        synchronized (mComponents)
        {
            GVRComponent comp = getComponent(componentType);
            if ((comp != null) && !visitor.visit(comp))
            {
                return;
            }
        }
        synchronized (mChildren)
        {
            for (int i = 0; i < mChildren.size(); ++i)
            {
                GVRSceneObject child = mChildren.get(i);
                child.forAllComponents(visitor, componentType);
            }
        }
    }

    /**
     * Visits all the components attached to
     * the descendants of this scene object.
     * The ComponentVisitor.visit function is called for every
     * component of each descendant until it returns false.
     * This allows you to traverse the scene graph safely without copying it.
     * This method gives much better performance than iterating
     * children() or getChildren().
     *
     * @param visitor ComponentVisitor interface implementing "visit" function
     *
     * @see #children()
     * @see #getChildren()
     * @see SceneVisitor
     * @see #forAllDescendants(SceneVisitor)
     * @see #getComponent(long)
     */
    public void forAllComponents(ComponentVisitor visitor)
    {
        synchronized (mComponents)
        {
            for (GVRComponent comp : mComponents.values())
            {
                if (!visitor.visit(comp))
                {
                    return;
                }
            }
        }
        synchronized (mChildren)
        {
            for (int i = 0; i < mChildren.size(); ++i)
            {
                GVRSceneObject child = mChildren.get(i);
                child.forAllComponents(visitor);
            }
        }
    }

    /**
     * Performs case-sensitive search
     *
     * @param name name of scene object to look for.
     * @return null if nothing was found or name was null/empty
     */
    public GVRSceneObject[] getSceneObjectsByName(final String name) {
        if (null == name || name.isEmpty()) {
            return null;
        }

        final List<GVRSceneObject> matches = new ArrayList<GVRSceneObject>();
        getSceneObjectsByName(name, matches);
        return 0 != matches.size() ? matches.toArray(new GVRSceneObject[matches.size()]) : null;
    }

    /**
     * Performs case-sensitive depth-first search
     *
     * @param name name of scene object to look for.
     * @return first match in the graph; null if nothing was found or name was null/empty;
     * in case there might be multiple matches consider using getSceneObjectsByName
     */
    public GVRSceneObject getSceneObjectByName(final String name) {
        if (null == name || name.isEmpty()) {
            return null;
        }
        if (getName().equals(name)) {
            return this;
        }
        for (GVRSceneObject child : mChildren) {
            GVRSceneObject found = child.getSceneObjectByName(name);
            if (found != null) {
                return found;
            }
        }
        return null;
    }

    protected void getSceneObjectsByName(final String name, List<GVRSceneObject> list) {
        if (name.equals(getName())) {
            list.add(this);
        }
        for (GVRSceneObject child : mChildren) {
            child.getSceneObjectsByName(name, list);
        }
    }

    /**
     * Check if {@code otherObject} is colliding with this object.
     *
     * @param otherObject
     *            {@link GVRSceneObject Object} to check for collision with this
     *            object.
     * @return {@code true} if objects collide, {@code false} otherwise
     */
    public boolean isColliding(GVRSceneObject otherObject) {
        return NativeSceneObject.isColliding(getNative(),
                otherObject.getNative());
    }

    /**
     * Designates whether the scene object should be displayed or not.
     * If a scene object is marked as not visible, none of its children
     * will be displayed either. This function only controls whether
     * your application wants to display the object and its children.
     * It does not tell you if GearVRf culled the object.
     *
     * @return true if scene object should be displayed, else false.
     */
    public boolean isEnabled() {
        return NativeSceneObject.isEnabled(getNative());
    }

    /**
     * Designates whether the scene object should be displayed or not.
     * If a scene object is not enabled, none of its children
     * will be displayed either.
     *
     * @param enable true the object will be displayed, if false it will not be.
     */
    public void setEnable(boolean enable) {
        NativeSceneObject.setEnable(getNative(), enable);
    }

    /**
     * Tests the {@link GVRSceneObject}s hierarchical bounding volume against
     * the specified ray.
     *
     * The ray is defined by its origin {@code [ox, oy, oz]} and its direction
     * {@code [dx, dy, dz]}.
     *
     * <p>
     * The ray origin may be [0, 0, 0] and the direction components should be
     * normalized from -1 to 1: Note that the y direction runs from -1 at the
     * bottom to 1 at the top.
     *
     * @param ox
     *            The x coordinate of the ray origin.
     *
     * @param oy
     *            The y coordinate of the ray origin.
     *
     * @param oz
     *            The z coordinate of the ray origin.
     *
     * @param dx
     *            The x vector of the ray direction.
     *
     * @param dy
     *            The y vector of the ray direction.
     *
     * @param dz
     *            The z vector of the ray direction.
     *
     * @return <code>true</code> if the input ray intersects with the
     *         {@link GVRSceneObject}s hierarchical bounding volume,
     *         <code>false</code> otherwise.
     */
    public boolean intersectsBoundingVolume(float ox, float oy, float oz, float dx,
                                            float dy, float dz) {
        return NativeSceneObject.rayIntersectsBoundingVolume(getNative(), ox, oy,
                oz, dx, dy, dz);
    }

    /**
     * Tests this {@link GVRSceneObject}'s hierarchical bounding volume against
     * the provided {@link GVRSceneObject}'s hierarchical bounding volume.
     *
     * @param otherObject the {@link GVRSceneObject} to check for intersection.
     * @return <code>true</code> if the object intersects with the
     * {@link GVRSceneObject}s hierarchical bounding volume,
     * <code>false</code> otherwise.
     */
    public boolean intersectsBoundingVolume(GVRSceneObject otherObject) {
        return NativeSceneObject.objectIntersectsBoundingVolume(getNative(), otherObject.getNative
                ());
    }

    /**
     * Get the number of child objects.
     *
     * @return Number of {@link GVRSceneObject objects} added as children of
     *         this object.
     */
    public int getChildrenCount() {
        return mChildren.size();
    }

    /**
     * Get the child object at {@code index}.
     *
     * @param index
     *            Position of the child to get.
     * @return {@link GVRSceneObject Child object}.
     *
     * @throws IndexOutOfBoundsException if there is no childat that position.
     */
    public GVRSceneObject getChildByIndex(int index) {
        return mChildren.get(index);
    }

    /**
     * As an alternative to calling {@link #getChildrenCount()} then repeatedly
     * calling {@link #getChildByIndex(int)}, you can
     *
     * <pre>
     * for (GVRSceneObject child : parent.children()) {
     * }
     * </pre>
     *
     * @return An {@link Iterable}, so you can use Java's enhanced for loop.
     *         This {@code Iterable} gives you an {@link Iterator} that does not
     *         support {@link Iterator#remove()}.
     *         <p>
     *         At some point, this might actually return a
     *         {@code List<GVRSceneObject>}, but that would require either
     *         creating an immutable copy or writing a lot of code to support
     *         methods like {@link List#addAll(java.util.Collection)} and
     *         {@link List#clear()} - for now, we just create a very
     *         light-weight class that only supports iteration.
     */
    public Iterable<GVRSceneObject> children() {
        return new Children(this);
    }


    /**
     * Get the {@link GVRSensor} if available.
     *
     * @return The {@link GVRSensor} attached to the node if available,
     *         <code>null</code> otherwise.
     */
    public GVRSensor getSensor() {
        return (GVRSensor) getComponent(GVRSensor.getComponentType());
    }

    /**
     * Get all the children, in a single list.
     *
     * @return An un-modifiable list of this object's children.
     *
     * @since 2.0.0
     */
    public List<GVRSceneObject> getChildren() {
        return Collections.unmodifiableList(mChildren);
    }

    /** The internal list - do not make any changes! */
    List<GVRSceneObject> rawGetChildren() {
        return mChildren;
    }

    private static class Children implements Iterable<GVRSceneObject>,
            Iterator<GVRSceneObject> {

        private final GVRSceneObject object;
        private int index;

        private Children(GVRSceneObject object) {
            this.object = object;
            this.index = 0;
        }

        @Override
        public Iterator<GVRSceneObject> iterator() {
            return this;
        }

        @Override
        public boolean hasNext() {
            return index < object.getChildrenCount();
        }

        @Override
        public GVRSceneObject next() {
            return object.getChildByIndex(index++);
        }

        @Override
        public void remove() {
            throw new UnsupportedOperationException();
        }
    }


    /**
     * Generate debug dump of the tree from the scene object.
     * It should include a newline character at the end.
     *
     * @param sb the {@code StringBuffer} to dump the object.
     * @param indent indentation level as number of spaces.
     */
    public void prettyPrint(StringBuffer sb, int indent) {
        sb.append(Log.getSpaces(indent));
        sb.append(getClass().getSimpleName());
        sb.append(" [name=");
        sb.append(this.getName());
        sb.append("]");
        sb.append(System.lineSeparator());
        GVRRenderData rdata = getRenderData();
        GVRTransform trans = getTransform();

        if (rdata == null) {
            sb.append(Log.getSpaces(indent + 2));
            sb.append("RenderData: null");
            sb.append(System.lineSeparator());
        } else {
            rdata.prettyPrint(sb, indent + 2);
        }
        sb.append(Log.getSpaces(indent + 2));
        sb.append("Transform: "); sb.append(trans);
        sb.append(System.lineSeparator());

        // dump its children
        for (GVRSceneObject child : getChildren()) {
            child.prettyPrint(sb, indent + 2);
        }
    }

    @Override
    public String toString() {
        StringBuffer sb = new StringBuffer();
        prettyPrint(sb, 0);
        return sb.toString();
    }

    @Override
    public GVREventReceiver getEventReceiver() {
        return mEventReceiver;
    }

    /**
     * Describes the BoundingVolume of this SceneObject.
     *
     * Describes the BoundingVolume of this SceneObject.  The bounding
     * volume encompases this GVRSceneObject and all of its children.
     * The volume includes both the bounding sphere (described by the center and radius) and the bounding box (described by the minCorner and maxCorner).
     *
     */
    public static final class BoundingVolume {
        public final Vector3f center;
        public final float radius;
        public final Vector3f minCorner;
        public final Vector3f maxCorner;
        private BoundingVolume(float[] rawValues) {
            center = new Vector3f(rawValues[0], rawValues[1], rawValues[2]);
            radius = rawValues[3];
            minCorner = new Vector3f(rawValues[4], rawValues[5], rawValues[6]);
            maxCorner = new Vector3f(rawValues[7], rawValues[8], rawValues[9]);
        }
    }

    /**
     * @return The BoundingVolume for this GVRSceneObject.
     */
    public final BoundingVolume getBoundingVolume() {
        return new BoundingVolume(NativeSceneObject.getBoundingVolume(getNative()));
    }

    float[] getBoundingVolumeRawValues() {
        return NativeSceneObject.getBoundingVolume(getNative());
    }

    /**
     * Expand the current volume by the given point
     * @param pointX    x coordinate of point
     * @param pointY    y coordinate of point
     * @param pointZ    z coordinate of point
     * @return the updated BoundingVolume.
     */
    public final BoundingVolume expandBoundingVolume(final float pointX, final float pointY, final float pointZ) {
        return new BoundingVolume(
                NativeSceneObject.expandBoundingVolumeByPoint(
                        getNative(), pointX, pointY, pointZ));
    }

    /**
     * Expand the current volume by the given point
     * @param point point to add to bounding volume.
     * @return the updated BoundingVolume.
     */
    public final BoundingVolume expandBoundingVolume(final Vector3f point) {
        return expandBoundingVolume(point.x, point.y, point.z);
    }

    /**
     * Expand the volume by the incoming center and radius
     * @param centerX   X coordinate of center.
     * @param centerY   Y coordinate of center.
     * @param centerZ   Z coordinate of center.
     * @param radius    radius to expand by.
     * @return the updated BoundingVolume.
     */
    public final BoundingVolume expandBoundingVolume(
            final float centerX, final float centerY, final float centerZ, final float radius) {
        return new BoundingVolume(
                NativeSceneObject.expandBoundingVolumeByCenterAndRadius(
                        getNative(), centerX, centerY, centerZ, radius));
    }

    /**
     * Expand the volume by the incoming center and radius
     * @param center new center
     * @param radius new radius
     * @return the updated BoundingVolume.
     */
    public final BoundingVolume expandBoundingVolume(final Vector3f center, final float radius) {
        return expandBoundingVolume(center.x, center.y, center.z, radius);
    }
}

class NativeSceneObject {
    static native long ctor();

    static native String getName(long sceneObject);

    static native void setName(long sceneObject, String name);

    static native boolean attachComponent(long sceneObject, long component);

    static native boolean detachComponent(long sceneObject, long type);

    static native long findComponent(long sceneObject, long type);

    static native void addChildObject(long sceneObject, long child);

    static native void removeChildObject(long sceneObject, long child);

    static native boolean isColliding(long sceneObject, long otherObject);

    static native boolean isEnabled(long sceneObject);

    static native void setEnable(long sceneObject, boolean flag);

    static native boolean rayIntersectsBoundingVolume(long sceneObject, float rox,
                                                      float roy, float roz, float rdx, float rdy, float rdz);

    static native boolean objectIntersectsBoundingVolume(long sceneObject, long otherObject);

    static native float[] getBoundingVolume(long sceneObject);

    static native float[] expandBoundingVolumeByPoint(
            long sceneObject, float pointX, float pointY, float pointZ);

    static native float[] expandBoundingVolumeByCenterAndRadius(
            long sceneObject, float centerX, float centerY, float centerZ, float radius);
}
