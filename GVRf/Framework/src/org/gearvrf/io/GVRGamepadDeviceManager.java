/* Copyright 2015 Samsung Electronics Co., LTD
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.gearvrf.io;

import java.util.HashSet;
import java.util.Set;

import org.gearvrf.GVRContext;
import org.gearvrf.GVRScene;
import org.gearvrf.GVRSceneObject;

import android.content.Context;
import android.opengl.Matrix;
import android.util.Log;
import android.util.SparseArray;
import android.view.InputDevice;
import android.view.KeyEvent;
import android.view.MotionEvent;

/**
 * Use this class to translate MotionEvents and KeyEvents generated by the
 * Controller/Gamepad to manipulate {@link GVRGamepadController}s.
 */
class GVRGamepadDeviceManager {
    private static final String TAG = GVRGamepadDeviceManager.class
            .getSimpleName();
    private static final int DELAY_MILLISECONDS = 16;

    private EventHandlerThread thread;
    private SparseArray<GVRGamepadController> controllers;
    private boolean threadStarted = false;

    /**
     * {@link GVRGamepadDeviceManager} is a helper class that can be used to
     * receive continuous x, y and z coordinate updates for a controller or a
     * gamepad device that is used with an Android device.
     * 
     * The main functions of this helper class are <br>
     * 
     * 1) To provide a separate thread to handle all the input events generated
     * by Android. This ensures that the main UI thread is not blocked while
     * performing GVRf actions. <br>
     * 
     * 2) Provide x, y, and z displacement values to the app. <br>
     * 
     * 3) Create a new {@link GVRGamepadController} object whenever a new
     * controller/gamepad device is detected by the {@link GVRInputManager}.
     * 
     * @param context
     *            The Android application context
     * @param activeButtons
     *            The list of all the buttons that will trigger the active
     *            pressed state of the controllers.<br>
     *            eg. use new int[] { KeyEvent.KEYCODE_BUTTON_A,
     *            KeyEvent.KEYCODE_BUTTON_B} to use button A and B as active
     *            buttons.
     * 
     */
    GVRGamepadDeviceManager(Context context, int[] activeButtons) {
        thread = new EventHandlerThread("GVRGamepadManagerThread",
                activeButtons);
        controllers = new SparseArray<GVRGamepadController>();
    }

    GVRBaseController getGVRCursorController(GVRContext context) {
        if (threadStarted == false) {
            thread.start();
            threadStarted = true;
        }

        GVRGamepadController controller = new GVRGamepadController(context,
                GVRCursorType.CONTROLLER, thread);
        int id = controller.getId();
        controllers.append(id, controller);
        return controller;
    }

    private static class GVRGamepadController extends GVRBaseController {
        private static final float MAX_RADIUS_SQUARE = 30.0f * 30.0f;
        private static final float MIN_RADIUS_SQUARE = 2.0f * 2.0f;

        private static final float[] UP_VECTOR = { 0.0f, 1.0f, 0.0f, 1.0f };
        private static final float[] RIGHT_VECTOR = { 1.0f, 0.0f, 0.0f, 1.0f };

        private static final float ONE_RADIAN = 1.0f;
        private static final float DEPTH_STEP = (float) (1
                / Math.toDegrees(ONE_RADIAN));

        // Change this value to increase or decrease the controller cursor speed
        private static final float SPEED = 20f;

        private EventHandlerThread thread;
        private GVRSceneObject internalObject;
        private GVRContext context;

        public GVRGamepadController(GVRContext context,
                GVRCursorType cursorType, EventHandlerThread thread) {
            super(cursorType);
            this.context = context;
            internalObject = new GVRSceneObject(context);
            internalObject.getTransform().setPosition(0.0f, 0.0f, -7.0f);
            this.thread = thread;
        }

        @Override
        public boolean dispatchKeyEvent(KeyEvent event) {
            if ((thread.isActive == false
                    && event.getAction() == KeyEvent.ACTION_DOWN)
                    || (thread.isActive == true
                            && event.getAction() == KeyEvent.ACTION_UP)) {
                return thread.submitKeyEvent(getId(), event);
            }
            return false;
        }

        @Override
        public boolean dispatchMotionEvent(MotionEvent event) {
            MotionEvent clone = MotionEvent.obtain(event);
            return thread.submitMotionEvent(getId(), clone);
        }

        private void processControllerEvent(float x, float y, float z,
                boolean active) {
            GVRScene scene = context.getMainScene();
            if (scene != null) {
                float[] viewMatrix = scene.getMainCameraRig().getHeadTransform()
                        .getModelMatrix();
                float[] xAxis = new float[4];
                float[] yAxis = new float[4];

                Matrix.multiplyMV(xAxis, 0, viewMatrix, 0, UP_VECTOR, 0);
                Matrix.multiplyMV(yAxis, 0, viewMatrix, 0, RIGHT_VECTOR, 0);

                float sensitivity = (50f + SPEED) / 100f;
                if (x != 0 || y != 0) {
                    float angle = (float) Math.atan2(y, x);
                    float displacementX = (float) Math.cos(angle);
                    float displacementY = (float) Math.sin(angle);
                    internalObject.getTransform().setRotation(1.0f, 0.0f, 0.0f,
                            0.0f);

                    internalObject.getTransform().rotateByAxisWithPivot(
                            -displacementX * sensitivity, xAxis[0], xAxis[1],
                            xAxis[2], 0.0f, 0.0f, 0.0f);
                    internalObject.getTransform().rotateByAxisWithPivot(
                            displacementY * sensitivity, yAxis[0], yAxis[1],
                            yAxis[2], 0.0f, 0.0f, 0.0f);

                }
                float[] controllerPosition = new float[] {
                        internalObject.getTransform().getPositionX(),
                        internalObject.getTransform().getPositionY(),
                        internalObject.getTransform().getPositionZ() };

                if (z != 0.0f) {
                    float step = (z < 0) ? DEPTH_STEP * sensitivity
                            : -DEPTH_STEP * sensitivity;

                    float[] point = {
                            controllerPosition[0]
                                    + controllerPosition[0] * step,
                            controllerPosition[1]
                                    + controllerPosition[1] * step,
                            controllerPosition[2]
                                    + controllerPosition[2] * step };

                    if (checkBounds(point)) {
                        internalObject.getTransform().setPosition(point[0],
                                point[1], point[2]);
                    }
                }
                setActive(active);
                setPosition(internalObject.getTransform().getPositionX(),
                        internalObject.getTransform().getPositionY(),
                        internalObject.getTransform().getPositionZ());
                invalidate();
            }
        }

        private boolean checkBounds(float[] point) {
            float lhs = square(point[0]) + square(point[1]) + square(point[2]);
            return (lhs <= MAX_RADIUS_SQUARE && lhs >= MIN_RADIUS_SQUARE);
        }

        private static float square(float x) {
            return x * x;
        }

    }

    private class EventHandlerThread extends Thread {
        private final Set<Integer> activeButtons;
        private int dpadState;
        private boolean isActive = false;
        private float x, y, ry;
        private Object lock = new Object();

        private boolean pedalDown = false;

        private EventDataHolder holder;

        private class EventDataHolder {
            private MotionEvent event;
            private KeyEvent keyEvent;
            private int id;

            public EventDataHolder(int id, MotionEvent event,
                    KeyEvent keyEvent) {
                this.id = id;
                this.event = event;
                this.keyEvent = keyEvent;
            }

            public void setId(int id) {
                this.id = id;
            }

            public void setEvent(MotionEvent event) {
                this.event = event;
            }

            public void setKeyEvent(KeyEvent keyEvent) {
                this.keyEvent = keyEvent;
            }
        }

        EventHandlerThread(String name, int[] activeButtons) {
            super(name);
            this.activeButtons = new HashSet<Integer>();
            for (int button = 0; button < activeButtons.length; button++) {
                this.activeButtons.add(activeButtons[button]);
            }
        }

        @Override
        public void run() {
            try {
                while (true) {
                    boolean running = false;
                    synchronized (lock) {
                        if (holder == null) {
                            lock.wait();
                        }

                        MotionEvent event = null;
                        KeyEvent keyEvent = null;
                        int id = -1;
                        if (holder != null) {
                            event = holder.event;
                            keyEvent = holder.keyEvent;
                            id = holder.id;
                        }
                        if (event != null) {
                            running = dispatchMotionEvent(id, event);
                            if (running == false) {
                                event.recycle();
                                event = null;
                                holder = null;
                            }
                        }
                        if (keyEvent != null) {
                            dispatchKeyEvent(id, keyEvent);
                            keyEvent = null;
                        }
                        GVRGamepadController controller = controllers.get(id);
                        controller.processControllerEvent(this.x, this.y,
                                this.ry, isActive);
                    }
                    Thread.sleep(DELAY_MILLISECONDS);
                }
            } catch (InterruptedException e) {
                Log.d(TAG, "EventHandlerThread stopped");
            }
        }

        private void dispatchKeyEvent(int id, KeyEvent event) {
            int keyCode = event.getKeyCode();
            int action = event.getAction();

            if (id != -1) {
                if (activeButtons.contains(keyCode)) {
                    if (action == KeyEvent.ACTION_DOWN && isActive == false) {
                        isActive = true;
                    } else
                        if (action == KeyEvent.ACTION_UP && isActive == true) {
                        isActive = false;
                    }
                } else {
                    switch (keyCode) {
                    case KeyEvent.KEYCODE_DPAD_LEFT:
                        if (action == KeyEvent.ACTION_DOWN
                                && dpadState != KeyEvent.KEYCODE_DPAD_LEFT) {
                            dpadState = KeyEvent.KEYCODE_DPAD_LEFT;

                            x = -1.0f;
                        } else if (action == KeyEvent.ACTION_UP) {
                            dpadState = 0;
                        }
                        break;
                    case KeyEvent.KEYCODE_DPAD_RIGHT:
                        if (action == KeyEvent.ACTION_DOWN
                                && dpadState != KeyEvent.KEYCODE_DPAD_RIGHT) {
                            dpadState = KeyEvent.KEYCODE_DPAD_RIGHT;
                            x = 1.0f;
                        } else if (action == KeyEvent.ACTION_UP) {
                            dpadState = 0;
                        }
                        break;
                    case KeyEvent.KEYCODE_DPAD_UP:
                        if (action == KeyEvent.ACTION_DOWN
                                && dpadState != KeyEvent.KEYCODE_DPAD_UP) {
                            dpadState = KeyEvent.KEYCODE_DPAD_UP;
                            y = 1.0f;
                        } else if (action == KeyEvent.ACTION_UP) {
                            dpadState = 0;
                        }
                        break;
                    case KeyEvent.KEYCODE_DPAD_DOWN:
                        if (action == KeyEvent.ACTION_DOWN
                                && dpadState != KeyEvent.KEYCODE_DPAD_DOWN) {
                            dpadState = KeyEvent.KEYCODE_DPAD_DOWN;
                            y = -1.0f;
                        } else if (action == KeyEvent.ACTION_UP) {
                            dpadState = 0;
                        }
                        break;
                    }

                }
            }
        }

        boolean submitMotionEvent(int id, MotionEvent event) {
            if (threadStarted && event.isFromSource(InputDevice.SOURCE_GAMEPAD)
                    || event.isFromSource(InputDevice.SOURCE_JOYSTICK)) {
                MotionEvent clone = MotionEvent.obtain(event);

                synchronized (lock) {
                    // There are cases of null events being passed.
                    if (event != null) {
                        event.recycle();
                    }

                    if (holder == null) {
                        this.holder = new EventDataHolder(id, clone, null);
                    } else {
                        holder.setId(id);
                        holder.setEvent(clone);
                    }
                    lock.notify();
                }
                return true;
            } else {
                return false;
            }
        }

        boolean submitKeyEvent(int id, KeyEvent event) {
            if (threadStarted && event.isFromSource(InputDevice.SOURCE_GAMEPAD)
                    || event.isFromSource(InputDevice.SOURCE_JOYSTICK)) {
                synchronized (lock) {
                    if (holder == null) {
                        this.holder = new EventDataHolder(id, null, event);
                    } else {
                        holder.setId(id);
                        holder.setKeyEvent(event);
                    }
                    lock.notify();
                }
                return true;
            } else {
                return false;
            }
        }

        // The following methods are taken from the controller sample on the
        // Android Developer web site:
        // https://developer.android.com/training/game-controllers/controller-input.html
        private boolean dispatchMotionEvent(int id, MotionEvent event) {
            if (event.getAction() == MotionEvent.ACTION_MOVE) {
                if (id != -1) {
                    return processJoystickInput(event);
                }
            }
            return false;
        }

        private boolean processJoystickInput(MotionEvent event) {
            InputDevice device = event.getDevice();
            float x = getCenteredAxis(event, device, MotionEvent.AXIS_X);
            if (x == 0) {
                x = getCenteredAxis(event, device, MotionEvent.AXIS_HAT_X);
            }

            float y = getCenteredAxis(event, device, MotionEvent.AXIS_Y);
            if (y == 0) {
                y = getCenteredAxis(event, device, MotionEvent.AXIS_HAT_Y);
            }

            float ry = 0.0f;
            int vendorId = device.getVendorId();
            int productId = device.getProductId();

            if (vendorId == GVRDeviceConstants.SAMSUNG_GAMEPAD_VENDOR_ID
                    && productId == GVRDeviceConstants.SAMSUNG_GAMEPAD_PRODUCT_ID) {
                ry = getCenteredAxis(event, device, MotionEvent.AXIS_RY);
            } else
                if ((vendorId == GVRDeviceConstants.SONY_DUALSHOCK_CONTROLLER_VENDOR_ID
                        && (productId == GVRDeviceConstants.SONY_DUALSHOCK_3_CONTROLLER_PRODUCT_ID
                                || productId == GVRDeviceConstants.SONY_DUALSHOCK_4_CONTROLLER_PRODUCT_ID))) {
                ry = getCenteredAxis(event, device, MotionEvent.AXIS_RZ);
            } else if ((vendorId == GVRDeviceConstants.STEELSERIES_CONTROLLER_VENDOR_ID
                    && productId == GVRDeviceConstants.STEELSERIES_CONTROLLER_PRODUCT_ID)) {
                ry = getCenteredAxis(event, device, MotionEvent.AXIS_RZ);
                if ((getCenteredAxis(event, device, MotionEvent.AXIS_BRAKE) != 0
                        || getCenteredAxis(event, device,
                                MotionEvent.AXIS_GAS) != 0)
                        && pedalDown == false) {
                    pedalDown = true;
                    if (isActive == false) {
                        isActive = true;
                    }
                } else if ((getCenteredAxis(event, device,
                        MotionEvent.AXIS_BRAKE) == 0
                        && getCenteredAxis(event, device,
                                MotionEvent.AXIS_GAS) == 0)
                        && pedalDown == true) {
                    pedalDown = false;
                    if (isActive == true) {
                        isActive = false;
                    }
                }
            }

            this.x = x;
            this.y = -y;
            this.ry = ry;

            if (x == 0 && y == 0 && ry == 0) {
                return false;
            } else {
                return true;
            }
        }

        private float getCenteredAxis(MotionEvent event, InputDevice device,
                int axis) {
            final InputDevice.MotionRange range = device.getMotionRange(axis,
                    event.getSource());
            if (range != null) {
                final float flat = range.getFlat();
                final float value = event.getAxisValue(axis);
                if (Math.abs(value) > flat) {
                    return value;
                }
            }
            return 0;
        }
    }

    void stop() {
        if (threadStarted) {
            thread.interrupt();
        }
    }
}